{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst UiGenerateMargin = (marginProp, directionProp) => {\n  let margin = '';\n  let direction;\n\n  const marginDetect = () => {\n    return marginProp.reduce((acc, item, index) => {\n      acc += item + 'px ';\n      return acc;\n    }, '');\n  };\n\n  if (marginProp.constructor === Array || !isNaN(marginProp)) {\n    margin = typeof marginProp === 'number' ? marginProp + 'px' : marginDetect() || '0px';\n  } else margin = 0;\n\n  if (directionProp) {\n    direction = _objectSpread(_objectSpread({}, directionProp === 'center' ? {\n      marginLeft: 'auto',\n      marginRight: 'auto'\n    } : {}), {}, {\n      [directionProp === 'right' ? 'marginLeft' : 'marginRight']: 'auto'\n    });\n  }\n\n  return _objectSpread({\n    margin\n  }, direction);\n};\n\nconst UIGetMarginLeftRight = margin => {\n  if (margin.constructor === Array) {\n    if (margin.length === 1) return 2 * margin[0];\n    return ((margin[1] || 0) + (margin[3] || 0)) * (margin[3] || margin[3] === 0 ? 1 : 2);\n  } else if (typeof margin === 'number') return margin * 2;\n};\n\nexport { UiGenerateMargin, UIGetMarginLeftRight };","map":{"version":3,"sources":["C:/Users/arthu/OneDrive/Desktop/Important/daser/next/test/utils/handlers.js"],"names":["UiGenerateMargin","marginProp","directionProp","margin","direction","marginDetect","reduce","acc","item","index","constructor","Array","isNaN","marginLeft","marginRight","UIGetMarginLeftRight","length"],"mappings":";;;;;;AAAA,MAAMA,gBAAgB,GAAG,CAACC,UAAD,EAAaC,aAAb,KAA+B;AACpD,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,SAAJ;;AACA,QAAMC,YAAY,GAAG,MAAM;AACvB,WAAOJ,UAAU,CAACK,MAAX,CAAkB,CAACC,GAAD,EAAMC,IAAN,EAAYC,KAAZ,KAAsB;AAC3CF,MAAAA,GAAG,IAAIC,IAAI,GAAG,KAAd;AACA,aAAOD,GAAP;AACH,KAHM,EAGJ,EAHI,CAAP;AAIH,GALD;;AAMA,MAAIN,UAAU,CAACS,WAAX,KAA2BC,KAA3B,IAAoC,CAACC,KAAK,CAACX,UAAD,CAA9C,EAA4D;AACxDE,IAAAA,MAAM,GAAG,OAAOF,UAAP,KAAsB,QAAtB,GACLA,UAAU,GAAG,IADR,GACeI,YAAY,MAAM,KAD1C;AAEH,GAHD,MAGOF,MAAM,GAAG,CAAT;;AACP,MAAID,aAAJ,EAAmB;AACfE,IAAAA,SAAS,mCACDF,aAAa,KAAK,QAAlB,GAA6B;AAC7BW,MAAAA,UAAU,EAAE,MADiB;AAE7BC,MAAAA,WAAW,EAAE;AAFgB,KAA7B,GAGD,EAJE;AAKL,OAACZ,aAAa,KAAK,OAAlB,GAA4B,YAA5B,GAA2C,aAA5C,GAA4D;AALvD,MAAT;AAOH;;AACD;AACIC,IAAAA;AADJ,KAEOC,SAFP;AAIH,CA1BD;;AA4BA,MAAMW,oBAAoB,GAAIZ,MAAD,IAAY;AACrC,MAAIA,MAAM,CAACO,WAAP,KAAuBC,KAA3B,EAAkC;AAC9B,QAAIR,MAAM,CAACa,MAAP,KAAkB,CAAtB,EAAyB,OAAO,IAAIb,MAAM,CAAC,CAAD,CAAjB;AACzB,WAAO,CAAC,CAACA,MAAM,CAAC,CAAD,CAAN,IAAa,CAAd,KAAoBA,MAAM,CAAC,CAAD,CAAN,IAAa,CAAjC,CAAD,KAA0CA,MAAM,CAAC,CAAD,CAAN,IAAaA,MAAM,CAAC,CAAD,CAAN,KAAc,CAA5B,GAAiC,CAAjC,GAAqC,CAA9E,CAAP;AACH,GAHD,MAGO,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC,OAAOA,MAAM,GAAG,CAAhB;AAC1C,CALD;;AAOA,SACIH,gBADJ,EAEIe,oBAFJ","sourcesContent":["const UiGenerateMargin = (marginProp, directionProp) => {\r\n    let margin = '';\r\n    let direction;\r\n    const marginDetect = () => {\r\n        return marginProp.reduce((acc, item, index) => {\r\n            acc += item + 'px ';\r\n            return acc\r\n        }, '')\r\n    }\r\n    if (marginProp.constructor === Array || !isNaN(marginProp)) {\r\n        margin = typeof marginProp === 'number' ?\r\n            marginProp + 'px' : marginDetect() || '0px';\r\n    } else margin = 0;\r\n    if (directionProp) {\r\n        direction = {\r\n            ...(directionProp === 'center' ? {\r\n                marginLeft: 'auto',\r\n                marginRight: 'auto',\r\n            }: {}),\r\n            [directionProp === 'right' ? 'marginLeft' : 'marginRight']: 'auto',\r\n        };\r\n    }\r\n    return {\r\n        margin,\r\n        ...direction,\r\n    }\r\n}\r\n\r\nconst UIGetMarginLeftRight = (margin) => {\r\n    if (margin.constructor === Array) {\r\n        if (margin.length === 1) return 2 * margin[0];\r\n        return ((margin[1] || 0) + (margin[3] || 0)) * ((margin[3] || margin[3] === 0) ? 1 : 2)\r\n    } else if (typeof margin === 'number') return margin * 2\r\n}\r\n\r\nexport {\r\n    UiGenerateMargin,\r\n    UIGetMarginLeftRight,\r\n};"]},"metadata":{},"sourceType":"module"}